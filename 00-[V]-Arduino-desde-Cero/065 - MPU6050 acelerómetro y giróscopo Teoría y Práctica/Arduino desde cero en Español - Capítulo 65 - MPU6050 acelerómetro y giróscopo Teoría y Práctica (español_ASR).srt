1
00:00:00,980 --> 00:00:05,720
hola a todos y bienvenidos a un nuevo

2
00:00:03,439 --> 00:00:06,439
capítulo de arduino desde cero en

3
00:00:05,719 --> 00:00:08,980
español

4
00:00:06,440 --> 00:00:13,400
en esta oportunidad veremos un módulo

5
00:00:08,980 --> 00:00:15,129
acelerómetro y giroscopio modelo ma60 50

6
00:00:13,400 --> 00:00:17,838
el cual nos permitirá obtener

7
00:00:15,128 --> 00:00:20,809
aceleración lineal y velocidad de

8
00:00:17,838 --> 00:00:23,210
rotación sobre tres ejes y con dichos

9
00:00:20,809 --> 00:00:25,219
datos ángulos de inclinación para

10
00:00:23,210 --> 00:00:27,560
diversidad de proyectos como hacer

11
00:00:25,219 --> 00:00:29,989
plataformas de estabilización y

12
00:00:27,559 --> 00:00:32,118
vehículos aéreos no tripulados entre

13
00:00:29,989 --> 00:00:34,549
otros nos centraremos en entender su

14
00:00:32,118 --> 00:00:37,308
principio de funcionamiento conexión con

15
00:00:34,549 --> 00:00:38,929
arduino y aplicación práctica mucha

16
00:00:37,308 --> 00:00:41,929
información en este capítulo

17
00:00:38,929 --> 00:00:44,000
así que iniciemos ya mismo en la imagen

18
00:00:41,929 --> 00:00:46,039
se muestra el módulo que lleva el nombre

19
00:00:44,000 --> 00:00:49,280
de su sensor mp

20
00:00:46,039 --> 00:00:52,010
60 50 el cual opera con una tensión de

21
00:00:49,280 --> 00:00:54,170
33 volts pero gracias al regulador

22
00:00:52,009 --> 00:00:56,899
incorporado en el módulo podemos

23
00:00:54,170 --> 00:00:57,920
alimentar de forma directa con 5 volts

24
00:00:56,899 --> 00:00:59,960
de arduino

25
00:00:57,920 --> 00:01:03,469
el sensor se encuentra en la categoría

26
00:00:59,960 --> 00:01:06,620
de y mv siglas en inglés de unidad de

27
00:01:03,469 --> 00:01:09,379
medición inercial consta de un acelerón

28
00:01:06,620 --> 00:01:11,990
de tres ejes un giróscopo también

29
00:01:09,379 --> 00:01:15,949
denominado giroscopio de también tres

30
00:01:11,989 --> 00:01:18,500
ejes y uno de mp siglas de procesador de

31
00:01:15,950 --> 00:01:20,750
movimiento digital el cual toma los

32
00:01:18,500 --> 00:01:23,030
datos de los sensores y aplica un

33
00:01:20,750 --> 00:01:25,969
procesamiento para enviar mediante el

34
00:01:23,030 --> 00:01:28,579
bass serie y 12 información ya pre

35
00:01:25,969 --> 00:01:31,099
procesada y de esa forma quitarle carga

36
00:01:28,579 --> 00:01:33,709
al microcontrolador este sensor lo

37
00:01:31,099 --> 00:01:36,799
encontrarás también referido como 6d o

38
00:01:33,709 --> 00:01:39,349
efe donde -dijo- efe son las siglas de

39
00:01:36,799 --> 00:01:42,469
grados de libertad ya que podremos medir

40
00:01:39,349 --> 00:01:45,049
dos magnitudes en tres ejes dando un

41
00:01:42,469 --> 00:01:47,480
total de seis existen módulos que

42
00:01:45,049 --> 00:01:50,750
incorporan un magnetómetro como el que

43
00:01:47,480 --> 00:01:53,540
vimos en el capítulo 48 en ese caso ya

44
00:01:50,750 --> 00:01:55,760
se convierte en un módulo de 9 grados de

45
00:01:53,540 --> 00:01:58,370
libertad al incorporar el campo

46
00:01:55,760 --> 00:02:00,530
magnético sobre tres ejes en este

47
00:01:58,370 --> 00:02:02,870
diagrama en bloque se puede apreciar que

48
00:02:00,530 --> 00:02:05,239
existe una cantidad considerable de

49
00:02:02,870 --> 00:02:06,950
procesamiento en un dispositivo de

50
00:02:05,239 --> 00:02:08,829
dimensiones reducidas

51
00:02:06,950 --> 00:02:11,060
aquí se marcan seis bloques

52
00:02:08,830 --> 00:02:12,469
correspondientes a los tres ejes del

53
00:02:11,060 --> 00:02:15,680
acelerómetro y los

54
00:02:12,469 --> 00:02:18,699
eje del giróscopo estos sensores son del

55
00:02:15,680 --> 00:02:21,170
tipo mems siglas de sistemas

56
00:02:18,699 --> 00:02:23,479
microelectromecánicos ya que realmente

57
00:02:21,169 --> 00:02:27,679
para medir aceleración lineal y

58
00:02:23,479 --> 00:02:29,989
velocidad de giro lmp 60 50 se fabrica

59
00:02:27,680 --> 00:02:32,360
con materiales híbridos donde existen

60
00:02:29,990 --> 00:02:35,300
movimientos microscópicos que permiten

61
00:02:32,360 --> 00:02:37,700
medir fuerzas aplicadas entonces debemos

62
00:02:35,300 --> 00:02:40,040
entender primero qué es lo que mide el

63
00:02:37,699 --> 00:02:42,769
sensor comenzando con el acelerómetro

64
00:02:40,039 --> 00:02:44,650
aquí debajo la definición y el

65
00:02:42,770 --> 00:02:47,750
acelerómetro mide la aceleración

66
00:02:44,650 --> 00:02:49,939
inercial o equivalente al cambio de

67
00:02:47,750 --> 00:02:52,069
velocidad en el tiempo la forma

68
00:02:49,939 --> 00:02:54,680
didáctica de mostrar su funcionamiento

69
00:02:52,069 --> 00:02:57,349
es con una masa denominada masa de

70
00:02:54,680 --> 00:02:59,659
prueba representada por este bloque la

71
00:02:57,349 --> 00:03:02,719
cual se encuentra suspendida en dos de

72
00:02:59,659 --> 00:03:05,539
sus extremos con resortes a puntos fijos

73
00:03:02,719 --> 00:03:08,599
estas dos líneas verticales indican

74
00:03:05,539 --> 00:03:11,629
puntos fijos de manera de restringir el

75
00:03:08,599 --> 00:03:14,479
movimiento sobre un único eje dicho eje

76
00:03:11,629 --> 00:03:16,400
será el eje de sensibilidad conectada a

77
00:03:14,479 --> 00:03:19,098
la masa tendremos una aguja

78
00:03:16,400 --> 00:03:20,658
que se desplaza sobre una escala ahora

79
00:03:19,098 --> 00:03:23,179
está en cero porque se encuentra en

80
00:03:20,658 --> 00:03:25,609
reposo si aplicamos una fuerza en el

81
00:03:23,180 --> 00:03:28,579
sentido de la flecha roja se producirá

82
00:03:25,610 --> 00:03:30,500
una aceleración de la masa de prueba la

83
00:03:28,579 --> 00:03:33,109
misma se desplaza en nuestro gráfico

84
00:03:30,500 --> 00:03:35,479
hacia la derecha y la aceleración que

85
00:03:33,109 --> 00:03:38,299
experimenta la representamos con la

86
00:03:35,479 --> 00:03:40,578
flecha azul verás que este resorte se

87
00:03:38,299 --> 00:03:43,040
expande mientras que este otro se

88
00:03:40,579 --> 00:03:44,269
comprime y la aguja apunta hacia el

89
00:03:43,039 --> 00:03:46,158
número uno

90
00:03:44,269 --> 00:03:49,459
vuelvo brevemente a la anterior imagen

91
00:03:46,158 --> 00:03:52,068
con la masa en reposo y podrás notar el

92
00:03:49,459 --> 00:03:54,319
cambio luego de aplicada la aceleración

93
00:03:52,068 --> 00:03:57,169
lineal y su efecto es una fuerza

94
00:03:54,318 --> 00:04:00,439
proporcional y de sentido opuesta

95
00:03:57,169 --> 00:04:02,419
denominada fuerza ficticia o fuerza de

96
00:04:00,439 --> 00:04:04,938
inercia se dice que es una fuerza

97
00:04:02,419 --> 00:04:07,488
ficticia porque no es la verdadera

98
00:04:04,938 --> 00:04:09,979
aplicada al sistema se produce como

99
00:04:07,489 --> 00:04:12,438
efecto de la misma pero lo importante es

100
00:04:09,979 --> 00:04:14,328
que es proporcional a la verdadera la

101
00:04:12,438 --> 00:04:17,449
flecha roja que es la que nos interesa

102
00:04:14,329 --> 00:04:19,430
medir con el acelerómetro por cierto la

103
00:04:17,449 --> 00:04:21,049
aceleración aplicada en este ejemplo

104
00:04:19,430 --> 00:04:25,280
sería de 1

105
00:04:21,048 --> 00:04:27,709
un g equivale a 98 metros sobre segundos

106
00:04:25,279 --> 00:04:30,258
al cuadrado claro que dentro del sensor

107
00:04:27,709 --> 00:04:32,719
todo es a nivel microscópico pero de

108
00:04:30,259 --> 00:04:35,000
hecho existe una masa de prueba que

109
00:04:32,720 --> 00:04:37,520
permite moverse y la medición de la

110
00:04:35,000 --> 00:04:40,000
fuerza a ficticia se realiza mediante la

111
00:04:37,519 --> 00:04:43,189
modificación de una capacitancia

112
00:04:40,000 --> 00:04:45,918
básicamente dos placas que se acercan o

113
00:04:43,189 --> 00:04:48,439
se alejan entonces de esa manera podemos

114
00:04:45,918 --> 00:04:52,158
medir la aceleración lineal sobre un eje

115
00:04:48,439 --> 00:04:54,228
nuestro sensor mp u 60 50 tiene tres

116
00:04:52,158 --> 00:04:56,689
sensores para medir la aceleración

117
00:04:54,228 --> 00:04:59,089
lineal sobre los tres ejes aquí se

118
00:04:56,689 --> 00:05:01,250
muestran la imagen del módulo donde es

119
00:04:59,089 --> 00:05:03,500
importante notar que sobre el circuito

120
00:05:01,250 --> 00:05:06,860
impreso se encuentra enmarcado en los

121
00:05:03,500 --> 00:05:09,709
ejes este de aquí es el eje x podemos

122
00:05:06,860 --> 00:05:11,750
hacer una línea imaginaria que pase por

123
00:05:09,709 --> 00:05:14,508
el centro del sensor y tenga la

124
00:05:11,750 --> 00:05:17,930
dirección y sentido indicado aquí está

125
00:05:14,509 --> 00:05:20,840
la marca de cuál es el eje y nuevamente

126
00:05:17,930 --> 00:05:23,810
podemos dibujar la línea para dicho eje

127
00:05:20,839 --> 00:05:26,598
y por último que no está marcado es el

128
00:05:23,810 --> 00:05:27,949
eje z el perpendicular al plano del

129
00:05:26,598 --> 00:05:30,829
circuito impreso

130
00:05:27,949 --> 00:05:33,589
que atraviesa el sensor de abajo hacia

131
00:05:30,829 --> 00:05:36,079
arriba la ubicación del sensor es de

132
00:05:33,589 --> 00:05:38,869
vital importancia para cuando obtengamos

133
00:05:36,079 --> 00:05:41,569
valores de aceleración lineal muy bien

134
00:05:38,870 --> 00:05:44,209
resta entonces analizar lo que mide un

135
00:05:41,569 --> 00:05:46,699
giróscopo o giroscopio vamos con la

136
00:05:44,209 --> 00:05:49,310
definición el giróscopo mide la

137
00:05:46,699 --> 00:05:52,639
velocidad angular alrededor de un eje

138
00:05:49,310 --> 00:05:56,180
también se la denomina velocidad de giro

139
00:05:52,639 --> 00:05:58,789
o momento angular usaremos la misma masa

140
00:05:56,180 --> 00:06:01,579
de prueba de antes pero en este caso se

141
00:05:58,790 --> 00:06:04,730
encuentra suspendida a un punto fijo por

142
00:06:01,579 --> 00:06:07,550
un único resorte del lado opuesto se

143
00:06:04,730 --> 00:06:10,250
aplica una fuerza oscilante sobre el eje

144
00:06:07,550 --> 00:06:12,920
x marcado con esta ve corta y las

145
00:06:10,250 --> 00:06:14,990
flechas a cada lado en definitiva podrás

146
00:06:12,920 --> 00:06:17,689
imaginar que la masa se mueve

147
00:06:14,990 --> 00:06:20,150
constantemente de forma controlada a

148
00:06:17,689 --> 00:06:22,730
derecha e izquierda si sobre el eje

149
00:06:20,149 --> 00:06:26,299
zetas se aplica una fuerza de rotación

150
00:06:22,730 --> 00:06:28,910
aparecerá una fuerza sobre el eje y por

151
00:06:26,300 --> 00:06:31,730
efecto coriolis como es una aceleración

152
00:06:28,910 --> 00:06:34,460
lineal la podemos medir como hicimos con

153
00:06:31,730 --> 00:06:37,610
el acelerómetro y nuevamente será

154
00:06:34,459 --> 00:06:40,370
a la velocidad de rotación en este caso

155
00:06:37,610 --> 00:06:42,439
particular sobre el eje z si aplicamos

156
00:06:40,370 --> 00:06:44,750
el concepto al resto de los ejes

157
00:06:42,439 --> 00:06:47,120
tendremos entonces la posibilidad de

158
00:06:44,750 --> 00:06:50,779
medir la velocidad de rotación sobre los

159
00:06:47,120 --> 00:06:53,629
ejes x y y ceta que es en grados por

160
00:06:50,779 --> 00:06:55,788
segundo de esa forma en esta imagen se

161
00:06:53,629 --> 00:07:00,199
resumen las magnitudes que podemos medir

162
00:06:55,788 --> 00:07:02,509
con el mpv 60 50 aceleración lineal y

163
00:07:00,199 --> 00:07:05,569
velocidad de rotación sobre los tres

164
00:07:02,509 --> 00:07:07,580
ejes resta sólo un concepto más y

165
00:07:05,569 --> 00:07:10,098
prometo que suficiente de teoría por el

166
00:07:07,579 --> 00:07:11,740
capítulo pero como siempre la idea es

167
00:07:10,098 --> 00:07:14,659
entender el principio de funcionamiento

168
00:07:11,740 --> 00:07:16,970
de los sensores y dispositivos que

169
00:07:14,660 --> 00:07:19,340
utilizamos en la práctica lo que nos

170
00:07:16,970 --> 00:07:21,830
interesa obtener del sensor son los

171
00:07:19,339 --> 00:07:24,649
ángulos respecto de una posición inicial

172
00:07:21,829 --> 00:07:27,228
para eso utilizaremos los movimientos

173
00:07:24,649 --> 00:07:29,508
que puede lograr un avión una forma

174
00:07:27,228 --> 00:07:32,418
didáctica de entender el tema y

175
00:07:29,509 --> 00:07:34,970
ampliamente usado en la enseñanza

176
00:07:32,418 --> 00:07:37,969
tenemos este bonito avión donde por el

177
00:07:34,970 --> 00:07:39,949
centro de masa pasan los ejes los mismos

178
00:07:37,970 --> 00:07:41,150
que vimos para el sensor de hecho

179
00:07:39,949 --> 00:07:45,470
podremos imaginar

180
00:07:41,149 --> 00:07:48,019
en este punto colocamos al mp 60 50 el

181
00:07:45,470 --> 00:07:50,510
eje z se encuentra en la misma dirección

182
00:07:48,019 --> 00:07:53,269
pero en sentido opuesto apuntando hacia

183
00:07:50,509 --> 00:07:55,969
abajo ya que es la forma estándar para

184
00:07:53,269 --> 00:07:58,819
vehículos en el aire este es el eje y

185
00:07:55,970 --> 00:08:01,970
vamos a aplicar una rotación sobre el

186
00:07:58,819 --> 00:08:04,459
mismo únicamente sobre este eje el resto

187
00:08:01,970 --> 00:08:07,040
queda sin modificar a la rotación de

188
00:08:04,459 --> 00:08:09,349
este eje en específico genera el

189
00:08:07,040 --> 00:08:12,110
denominado nombre en inglés de pitch

190
00:08:09,350 --> 00:08:14,450
vamos a utilizar de aquí en adelante las

191
00:08:12,110 --> 00:08:16,520
palabras en inglés porque de esa forma

192
00:08:14,449 --> 00:08:19,099
es que encontrarás la información en la

193
00:08:16,519 --> 00:08:22,039
web cuando busques por datos adicionales

194
00:08:19,100 --> 00:08:24,410
o para aprender más del tema entonces

195
00:08:22,040 --> 00:08:26,990
por qué se le dice pitch a la rotación

196
00:08:24,410 --> 00:08:30,350
del eje y porque lo que produce en el

197
00:08:26,990 --> 00:08:33,080
avión es que la nariz suba o baje de

198
00:08:30,350 --> 00:08:35,180
acuerdo al sentido de giro aquí va una

199
00:08:33,080 --> 00:08:37,610
animación donde se puede observar el

200
00:08:35,179 --> 00:08:40,699
movimiento hay que acostumbrarse un poco

201
00:08:37,610 --> 00:08:43,820
quizás parezca poco natural girar el eje

202
00:08:40,700 --> 00:08:44,940
y y que produzca un movimiento sobre el

203
00:08:43,820 --> 00:08:47,490
eje x

204
00:08:44,940 --> 00:08:50,250
el eje x es este de aquí si aplicamos

205
00:08:47,490 --> 00:08:53,370
una rotación únicamente sobre este eje

206
00:08:50,250 --> 00:08:55,950
se produce el denominado roll o al ave o

207
00:08:53,370 --> 00:08:58,620
del avión nuevamente en la animación se

208
00:08:55,950 --> 00:09:01,200
puede ver que girando el eje x logramos

209
00:08:58,620 --> 00:09:04,289
que las alas del avión se muevan y por

210
00:09:01,200 --> 00:09:07,290
último la rotación sobre el eje z genera

211
00:09:04,289 --> 00:09:10,019
el denominado yo o guiñada que en esta

212
00:09:07,289 --> 00:09:12,870
otra animación se puede apreciar cómo

213
00:09:10,019 --> 00:09:15,419
hace que la nariz del avión se mueva a

214
00:09:12,870 --> 00:09:18,450
derecha o izquierda de manera que todo

215
00:09:15,419 --> 00:09:22,740
lo visto lleva los conceptos de yo pitch

216
00:09:18,450 --> 00:09:25,379
y roll con el mp 6050 podremos obtener

217
00:09:22,740 --> 00:09:27,840
los ángulos de los tres y saber la

218
00:09:25,379 --> 00:09:30,000
inclinación de dichos ejes respecto de

219
00:09:27,840 --> 00:09:32,550
una posición inicial cuando hagamos la

220
00:09:30,000 --> 00:09:34,679
práctica en breve verás como todo tiene

221
00:09:32,549 --> 00:09:37,649
sentido pero es importante tener en

222
00:09:34,679 --> 00:09:40,229
cuenta esta imagen de referencia genial

223
00:09:37,649 --> 00:09:43,019
vamos al circuito de conexión del módulo

224
00:09:40,230 --> 00:09:45,600
con arduino que será muy simple por ser

225
00:09:43,019 --> 00:09:48,569
un dispositivo con comunicación por más

226
00:09:45,600 --> 00:09:51,120
y 12 de veces se del módulo

227
00:09:48,570 --> 00:09:53,340
con un cable directo a la salida de 5

228
00:09:51,120 --> 00:09:57,629
volts de arduino como mencionaba al

229
00:09:53,340 --> 00:10:00,269
principio el mp 6050 funciona con 33

230
00:09:57,629 --> 00:10:03,480
pero el módulo incluye un regulador para

231
00:10:00,269 --> 00:10:05,970
alimentarlo con 5 de forma directa de

232
00:10:03,480 --> 00:10:06,840
gene de del módulo iremos a genere de

233
00:10:05,970 --> 00:10:10,379
arduino

234
00:10:06,840 --> 00:10:14,399
luego el base y 12 de ssl del módulo

235
00:10:10,379 --> 00:10:18,120
alpina analógico a 5 de arduino y de sda

236
00:10:14,399 --> 00:10:20,159
del módulo alpina analógico a 4

237
00:10:18,120 --> 00:10:22,889
finalmente conectaremos el pin con la

238
00:10:20,159 --> 00:10:25,259
denominación int que es la interrupción

239
00:10:22,889 --> 00:10:28,230
el que le indica arduino que existen

240
00:10:25,259 --> 00:10:30,929
datos válidos provenientes del sensor lo

241
00:10:28,230 --> 00:10:33,570
conectaremos al pin digital número 2 que

242
00:10:30,929 --> 00:10:36,419
corresponde a la interrupción 0

243
00:10:33,570 --> 00:10:39,000
el capítulo 21 lo dedicamos en exclusiva

244
00:10:36,419 --> 00:10:40,769
al análisis de las interrupciones en la

245
00:10:39,000 --> 00:10:43,320
nota se encuentra el resumen de

246
00:10:40,769 --> 00:10:46,139
conexiones y la diferencia con los pines

247
00:10:43,320 --> 00:10:51,300
en caso de usar el modelo mega siendo el

248
00:10:46,139 --> 00:10:54,149
pin 21 para ssl y 20 para sda el resto

249
00:10:51,299 --> 00:10:56,250
igual el pin de 0

250
00:10:54,149 --> 00:10:59,009
módulo se utiliza para establecer la

251
00:10:56,250 --> 00:11:01,889
dirección y 12 del mismo por defecto se

252
00:10:59,009 --> 00:11:04,110
encuentra forzado a massa mediante una

253
00:11:01,889 --> 00:11:06,600
resistencia de pull down por eso lo

254
00:11:04,110 --> 00:11:10,320
dejaremos sin conexión y de esa forma

255
00:11:06,600 --> 00:11:13,019
utilizar la dirección en hexadecimal 68

256
00:11:10,320 --> 00:11:15,510
si necesitamos cambiar la dirección o

257
00:11:13,019 --> 00:11:18,210
quisieras usar dos de estos módulos al

258
00:11:15,509 --> 00:11:21,240
mismo tiempo podrías colocar el pin a de

259
00:11:18,210 --> 00:11:24,960
0 a bcc y de esa forma cambiamos la

260
00:11:21,240 --> 00:11:28,860
dirección a la 69 los pines x de edad y

261
00:11:24,960 --> 00:11:31,500
x cl se utilizan en el caso opcional de

262
00:11:28,860 --> 00:11:33,930
incorporar un dispositivo y 12 como

263
00:11:31,500 --> 00:11:37,649
hacer un magnetómetro de esa manera el

264
00:11:33,929 --> 00:11:40,620
mp 6050 puede acceder por sus propios

265
00:11:37,649 --> 00:11:42,929
medios al dispositivo e integrar datos a

266
00:11:40,620 --> 00:11:45,299
su de mp pero es una función avanzada

267
00:11:42,929 --> 00:11:47,639
que ya excede el propósito de este

268
00:11:45,299 --> 00:11:50,579
capítulo de manera que para nuestro caso

269
00:11:47,639 --> 00:11:53,399
lo dejaremos sin conectar y eso es todo

270
00:11:50,580 --> 00:11:56,070
para la conexión vamos ahora a descargar

271
00:11:53,399 --> 00:11:58,470
un par de librerías para facilitarnos en

272
00:11:56,070 --> 00:11:59,959
la programación primero del repositorio

273
00:11:58,470 --> 00:12:03,480
de jeff

274
00:11:59,958 --> 00:12:06,448
descargaremos y 12 se trata de una

275
00:12:03,480 --> 00:12:08,850
librería para el manejo y 12 de código

276
00:12:06,448 --> 00:12:12,000
abierto y multiplataforma que

277
00:12:08,850 --> 00:12:14,699
complementa a la conocida wáyar incluida

278
00:12:12,000 --> 00:12:17,610
con el id de arduino dejaré como siempre

279
00:12:14,698 --> 00:12:19,948
un enlace en la zona de descripción con

280
00:12:17,610 --> 00:12:23,250
el acceso directo con el botón verde

281
00:12:19,948 --> 00:12:25,439
code seleccionamos downloads y para esto

282
00:12:23,250 --> 00:12:29,068
descargara el archivo comprimido con el

283
00:12:25,440 --> 00:12:31,889
nombre y 12 de live guión del medio

284
00:12:29,068 --> 00:12:34,289
master punto zip desde aquí mismo si

285
00:12:31,889 --> 00:12:36,778
estás usando el navegador chrome podrás

286
00:12:34,289 --> 00:12:39,419
hacer clic y se abre una ventana con el

287
00:12:36,778 --> 00:12:42,629
archivo ya ha descomprimido ingresamos a

288
00:12:39,419 --> 00:12:44,969
la carpeta y 12 debe libre del medio

289
00:12:42,629 --> 00:12:47,519
master y luego a otra carpeta para

290
00:12:44,970 --> 00:12:49,829
nuestra plataforma que claro está esa

291
00:12:47,519 --> 00:12:52,078
rutina aquí hay un listado de gran

292
00:12:49,828 --> 00:12:54,929
cantidad de sensores soportados en

293
00:12:52,078 --> 00:12:57,239
principio sólo nos interesa y 12 debe

294
00:12:54,929 --> 00:12:59,729
seleccionamos la carpeta y la copiamos

295
00:12:57,240 --> 00:13:03,209
miras que más abajo hay una librería

296
00:12:59,730 --> 00:13:05,970
para el mpv 60 50 no estaremos usando

297
00:13:03,208 --> 00:13:06,569
esta en particular ya que tiene un

298
00:13:05,970 --> 00:13:09,389
problema

299
00:13:06,570 --> 00:13:12,240
el monitor serie al ser usada en arduino

300
00:13:09,389 --> 00:13:14,399
de manera que por el momento solo y 12

301
00:13:12,240 --> 00:13:16,649
debe ya que tenemos copia de la carpeta

302
00:13:14,399 --> 00:13:18,840
debemos ingresar al directorio de

303
00:13:16,649 --> 00:13:20,549
librerías de arduino que suele estar por

304
00:13:18,840 --> 00:13:24,030
defecto en documentos

305
00:13:20,549 --> 00:13:26,429
arduino libraries así podrás pegar la

306
00:13:24,029 --> 00:13:28,309
carpeta anteriormente copiada

307
00:13:26,429 --> 00:13:32,159
finalmente descargaremos de la librería

308
00:13:28,309 --> 00:13:34,439
específica para el mpv 60 50 la que

309
00:13:32,159 --> 00:13:39,629
encontré que funciona muy bien y es

310
00:13:34,440 --> 00:13:42,380
relativamente simple es la simple mp 60

311
00:13:39,629 --> 00:13:45,330
50 nuevamente en la zona de descripción

312
00:13:42,379 --> 00:13:48,059
encontrarás el acceso directo del botón

313
00:13:45,330 --> 00:13:50,820
verde seleccionamos download zip

314
00:13:48,059 --> 00:13:55,319
descarga el archivo simple guión bajo

315
00:13:50,820 --> 00:13:57,480
mpv 60 50 guión del medio master punto

316
00:13:55,320 --> 00:14:00,210
zip en este caso no lo estaremos

317
00:13:57,480 --> 00:14:02,639
descomprimiendo en su lugar instalaremos

318
00:14:00,210 --> 00:14:05,009
la librería con el id de arduino de

319
00:14:02,639 --> 00:14:07,529
manera que vamos al mismo desde el menú

320
00:14:05,009 --> 00:14:10,350
programa seleccionamos incluir librería

321
00:14:07,529 --> 00:14:12,480
y luego añadir biblioteca punto zip

322
00:14:10,350 --> 00:14:13,200
seleccionamos el archivo recién

323
00:14:12,480 --> 00:14:15,779
descargado

324
00:14:13,200 --> 00:14:18,390
y abrir ya con eso tenemos todo lo

325
00:14:15,779 --> 00:14:21,509
necesario para comenzar a usar el sensor

326
00:14:18,389 --> 00:14:24,029
este primer programa es una modificación

327
00:14:21,509 --> 00:14:26,220
del de ejemplo incluido en la librería

328
00:14:24,029 --> 00:14:28,889
tratando de hacerlo lo más simple

329
00:14:26,220 --> 00:14:31,620
posible y eliminando algunas secciones

330
00:14:28,889 --> 00:14:34,379
no esenciales de todas maneras algunos

331
00:14:31,620 --> 00:14:36,450
nombres de funciones los mantuve sin

332
00:14:34,379 --> 00:14:39,120
cambios para no desviarme mucho del

333
00:14:36,450 --> 00:14:41,820
ejemplo al cual podrás recurrir en todo

334
00:14:39,120 --> 00:14:43,740
momento puede que parezca intimidante en

335
00:14:41,820 --> 00:14:46,500
un principio pero como siempre lo

336
00:14:43,740 --> 00:14:49,409
analizaremos en línea por línea haciendo

337
00:14:46,500 --> 00:14:51,090
énfasis en lo más importante la idea de

338
00:14:49,409 --> 00:14:54,839
este programa es mostrar mediante

339
00:14:51,090 --> 00:14:57,420
monitor serie los ángulos de pitch y

340
00:14:54,840 --> 00:14:59,910
roll de manera que al mover el sensor

341
00:14:57,419 --> 00:15:02,309
podamos visualizar los cambios en los

342
00:14:59,909 --> 00:15:06,839
valores la primera línea incluye la

343
00:15:02,309 --> 00:15:09,359
librería simple mp 60 50 y luego una

344
00:15:06,840 --> 00:15:12,360
serie de numeral design para definir la

345
00:15:09,360 --> 00:15:15,720
dirección y 12 del módulo dependiendo de

346
00:15:12,360 --> 00:15:18,509
cómo esté conectado el pin a de 0 por

347
00:15:15,720 --> 00:15:22,889
eso aquí define a mp3

348
00:15:18,509 --> 00:15:25,830
a de 0 low con 0 x 68 que es como

349
00:15:22,889 --> 00:15:28,889
nosotros lo tenemos configurado a de 0 a

350
00:15:25,830 --> 00:15:33,060
nivel bajo o sin conexión luego hace lo

351
00:15:28,889 --> 00:15:37,379
mismo para mp3 de 0 hi con la dirección

352
00:15:33,059 --> 00:15:40,019
0 x 69 he dicho a pin estuviese a nivel

353
00:15:37,379 --> 00:15:44,700
alto por último un numeral -define con

354
00:15:40,019 --> 00:15:47,610
el nombre mpv 60 50 default address es

355
00:15:44,700 --> 00:15:50,879
decir la dirección por defecto que es mp

356
00:15:47,610 --> 00:15:53,490
address a de 0 lo podríamos dejar el

357
00:15:50,879 --> 00:15:56,580
valor por defecto con la dirección 0 x

358
00:15:53,490 --> 00:15:59,039
68 para evitar un par de líneas pero lo

359
00:15:56,580 --> 00:16:01,500
dejaremos genérico para cualquier caso

360
00:15:59,039 --> 00:16:05,219
de uso luego creamos un objeto con el

361
00:16:01,500 --> 00:16:09,870
nombre mpv que será del tipo simple mp

362
00:16:05,220 --> 00:16:12,149
60 50 de este objeto mpv usaremos sus

363
00:16:09,870 --> 00:16:14,669
funciones asociadas para obtener

364
00:16:12,149 --> 00:16:16,799
diversos valores luego aparece esta

365
00:16:14,669 --> 00:16:18,809
función enable m

366
00:16:16,799 --> 00:16:20,789
overflow protection' la cual es

367
00:16:18,809 --> 00:16:24,929
necesaria para evitar problemas con el

368
00:16:20,789 --> 00:16:27,209
monitor serie resulta que el mp 60 50

369
00:16:24,929 --> 00:16:29,189
envía gran cantidad de datos y puede

370
00:16:27,210 --> 00:16:31,259
generar problemas con el buffer de

371
00:16:29,190 --> 00:16:33,060
nuestro arduino de hecho este es un

372
00:16:31,259 --> 00:16:36,000
problema que tiene la librería del

373
00:16:33,059 --> 00:16:38,669
desarrollador de donde descargamos y 12

374
00:16:36,000 --> 00:16:40,919
por eso la elección de esta librería en

375
00:16:38,669 --> 00:16:44,159
particular que funciona perfectamente

376
00:16:40,919 --> 00:16:46,469
bien esta línea comentada la dejaremos

377
00:16:44,159 --> 00:16:49,199
para explicar más adelante para no

378
00:16:46,470 --> 00:16:51,570
complicar y aquí con este numeral design

379
00:16:49,200 --> 00:16:55,080
el desarrollador define una función

380
00:16:51,570 --> 00:16:58,170
llamada span timer tiene una forma poco

381
00:16:55,080 --> 00:17:00,480
usual de crear una función todo en una

382
00:16:58,169 --> 00:17:02,699
sola línea lo que hace es crear una

383
00:17:00,480 --> 00:17:05,789
demora para mostrar los datos en el

384
00:17:02,700 --> 00:17:08,220
monitor serie pero sin usar delay aquí

385
00:17:05,789 --> 00:17:10,349
como estaremos usando interrupciones y

386
00:17:08,220 --> 00:17:12,838
gran cantidad de datos no es deseable

387
00:17:10,349 --> 00:17:15,928
generar bloqueos en el flujo del

388
00:17:12,838 --> 00:17:17,849
programa la función span timer ya lo

389
00:17:15,929 --> 00:17:21,300
usaremos en breve cuando escribiremos en

390
00:17:17,849 --> 00:17:23,250
el monitor serie es genérica y se pasa

391
00:17:21,299 --> 00:17:25,889
como parámetro la cantidad de

392
00:17:23,250 --> 00:17:27,539
milisegundos también aquí aparece otra

393
00:17:25,890 --> 00:17:30,690
función hecha a medida por el

394
00:17:27,539 --> 00:17:32,829
desarrollador con el nombre print

395
00:17:30,690 --> 00:17:34,960
seguramente te habrás encontrado en la

396
00:17:32,829 --> 00:17:37,629
situación donde la función print

397
00:17:34,960 --> 00:17:40,120
incorporada en el id de arduino no es

398
00:17:37,630 --> 00:17:42,460
muy flexible para mostrar datos por eso

399
00:17:40,119 --> 00:17:44,859
aquí se crea una función print pero

400
00:17:42,460 --> 00:17:47,259
extendida para mostrar datos con una

401
00:17:44,859 --> 00:17:50,019
sola línea en vez de utilizar múltiples

402
00:17:47,259 --> 00:17:52,929
sería el punto print así que no es del

403
00:17:50,019 --> 00:17:55,058
todo intuitivo pero como decía antes es

404
00:17:52,929 --> 00:17:57,309
la decisión del desarrollador al cual

405
00:17:55,058 --> 00:17:59,918
debemos acostumbrarnos aunque claro

406
00:17:57,308 --> 00:18:02,408
podríamos usar clásicos sería el punto

407
00:17:59,919 --> 00:18:05,470
print pero haría el código más largo por

408
00:18:02,409 --> 00:18:08,409
eso decidí no modificarlo los parámetros

409
00:18:05,470 --> 00:18:11,589
de la función print flow de exxon name

410
00:18:08,409 --> 00:18:13,720
que es el texto estático a mostrar antes

411
00:18:11,589 --> 00:18:15,759
del valor de la variable luego la

412
00:18:13,720 --> 00:18:18,880
variable a mostrar los espacios

413
00:18:15,759 --> 00:18:20,798
asignados a mostrarla la precisión

414
00:18:18,880 --> 00:18:23,740
esto es útil con valores del tipo

415
00:18:20,798 --> 00:18:26,349
flotante cloud como hacemos nosotros

416
00:18:23,740 --> 00:18:28,599
el siguiente parámetro and text

417
00:18:26,349 --> 00:18:31,480
determina qué haremos luego de mostrar

418
00:18:28,599 --> 00:18:33,969
la información si dejamos espacios si

419
00:18:31,480 --> 00:18:36,370
hacemos un salto de línea en definitiva

420
00:18:33,970 --> 00:18:39,100
la idea es que con una sola línea

421
00:18:36,369 --> 00:18:41,289
mostrar texto valor de la variable

422
00:18:39,099 --> 00:18:43,719
espacios reservados para la misma

423
00:18:41,289 --> 00:18:47,049
precisión para valores de punto flotante

424
00:18:43,720 --> 00:18:49,600
y texto final este bloque de código que

425
00:18:47,049 --> 00:18:51,909
marco es la función que es llamada desde

426
00:18:49,599 --> 00:18:54,069
loop cada vez que el sensor mediante la

427
00:18:51,910 --> 00:18:56,259
interrupción nos indica que existen

428
00:18:54,069 --> 00:18:59,109
valores disponibles tiene el nombre de

429
00:18:56,259 --> 00:19:01,299
mostrar valores lo dejaré de lado por el

430
00:18:59,109 --> 00:19:03,939
momento así seguimos con la secuencia

431
00:19:01,299 --> 00:19:06,609
natural que seguirá el programa en el

432
00:19:03,940 --> 00:19:09,490
setup colocaremos el código a ejecutarse

433
00:19:06,609 --> 00:19:11,229
por única vez al inicio este bloque es

434
00:19:09,490 --> 00:19:14,319
para establecer el parámetro de

435
00:19:11,230 --> 00:19:16,630
velocidad del bass y 12 recordad que

436
00:19:14,319 --> 00:19:19,629
estamos trabajando con la librería y 12

437
00:19:16,630 --> 00:19:22,780
debe en lugar de wáyar la velocidad se

438
00:19:19,630 --> 00:19:26,020
establece en 400 kilos hertz luego la

439
00:19:22,779 --> 00:19:30,428
inicialización del monitor serie a 115

440
00:19:26,019 --> 00:19:32,349
200 verás que no usamos el clásico 9.600

441
00:19:30,429 --> 00:19:34,990
esto es porque necesitamos obtener

442
00:19:32,349 --> 00:19:37,629
valores de forma rápida cuando subamos

443
00:19:34,990 --> 00:19:40,210
el programa y abramos el monitor serie

444
00:19:37,630 --> 00:19:43,000
te mostraré cómo cambiar la velocidad a

445
00:19:40,210 --> 00:19:45,700
115 200 de manera muy simple

446
00:19:43,000 --> 00:19:48,250
esta línea es para modelos leonardo o

447
00:19:45,700 --> 00:19:51,640
pro micro que integran de forma nativa

448
00:19:48,250 --> 00:19:55,029
usb para nosotros con arduino 1 y

449
00:19:51,640 --> 00:19:57,910
cualquier placa con la mega 328 p no

450
00:19:55,029 --> 00:20:00,519
tiene incidencia luego el texto estático

451
00:19:57,910 --> 00:20:02,950
inicio y veremos la aplicación de una

452
00:20:00,519 --> 00:20:06,579
directiva al compilador con el numeral

453
00:20:02,950 --> 00:20:09,160
yf de cuando comienza con numeral indica

454
00:20:06,579 --> 00:20:11,379
una directiva al compilador es una forma

455
00:20:09,160 --> 00:20:14,259
de decirle que en el momento de compilar

456
00:20:11,380 --> 00:20:17,170
el programa realice una consulta en

457
00:20:14,259 --> 00:20:19,629
pocas palabras dice que si es cierta

458
00:20:17,170 --> 00:20:21,970
determinada condición use parte del

459
00:20:19,630 --> 00:20:24,880
código en el programa que va a subir a

460
00:20:21,970 --> 00:20:27,579
la placa si no se da esa condición que

461
00:20:24,880 --> 00:20:28,630
incluya esta otra parte igual que un

462
00:20:27,579 --> 00:20:30,699
condicional

463
00:20:28,630 --> 00:20:33,430
pero que se ejecuta en el momento de la

464
00:20:30,700 --> 00:20:37,360
compilación la condición que consulta es

465
00:20:33,430 --> 00:20:39,519
si existen offsets todo en mayúscula es

466
00:20:37,359 --> 00:20:42,429
decir que si en alguna línea hay un

467
00:20:39,519 --> 00:20:45,400
numeral -define con el nombre offset se

468
00:20:42,430 --> 00:20:47,500
realiza esta acción si vamos un poco al

469
00:20:45,400 --> 00:20:48,340
principio del programa verás que existe

470
00:20:47,500 --> 00:20:51,038
un numeral

471
00:20:48,339 --> 00:20:54,459
con dicho nombre pero que está comentado

472
00:20:51,038 --> 00:20:56,710
y luego una serie de números offsets son

473
00:20:54,460 --> 00:20:59,440
las desviaciones que se pueden aplicar

474
00:20:56,710 --> 00:21:01,720
al sensor y se entenderá mejor cuando en

475
00:20:59,440 --> 00:21:03,880
breve hagamos la práctica pero deberás

476
00:21:01,720 --> 00:21:06,700
considerar que debemos iniciar con una

477
00:21:03,880 --> 00:21:09,610
posición del sensor que la considera el

478
00:21:06,700 --> 00:21:11,440
punto de inicio o referencia el sensor

479
00:21:09,609 --> 00:21:14,469
lo estaré colocando sobre protoboard

480
00:21:11,440 --> 00:21:17,679
entonces cuando inicia sería conveniente

481
00:21:14,470 --> 00:21:19,360
que tome ese punto como el inicial

482
00:21:17,679 --> 00:21:21,970
volvamos nuevamente a esta parte

483
00:21:19,359 --> 00:21:25,119
entonces preguntas si existe un numeral

484
00:21:21,970 --> 00:21:27,970
defile con el nombre offsets en nuestro

485
00:21:25,119 --> 00:21:30,219
caso es falso si bien existe tenemos

486
00:21:27,970 --> 00:21:32,769
comentada esa línea por dicho motivo

487
00:21:30,220 --> 00:21:36,460
estas dos líneas de código no las

488
00:21:32,769 --> 00:21:38,408
ejecuta vamos directamente al else aquí

489
00:21:36,460 --> 00:21:41,169
lo que hacemos es mostrar en el monitor

490
00:21:38,409 --> 00:21:43,570
serie este texto como es largo lo

491
00:21:41,169 --> 00:21:46,000
hacemos en varias líneas sólo texto

492
00:21:43,569 --> 00:21:48,579
estático indicando que no se

493
00:21:46,000 --> 00:21:50,740
establecieron offsets y haremos unos

494
00:21:48,579 --> 00:21:52,389
nuevos colocar el sensor en una

495
00:21:50,740 --> 00:21:55,029
superficie plana

496
00:21:52,390 --> 00:21:58,300
esperar unos segundos colocar los nuevos

497
00:21:55,029 --> 00:22:00,670
off sets con el numeral design of sets

498
00:21:58,299 --> 00:22:03,789
para saltar la calibración inicial

499
00:22:00,670 --> 00:22:06,519
presionar cualquier tecla y enter creo

500
00:22:03,789 --> 00:22:09,069
que el texto es bastante descriptivo nos

501
00:22:06,519 --> 00:22:12,039
dice que no hay objeto que va a crear

502
00:22:09,069 --> 00:22:14,769
unos nuevos y ubicamos el sensor sin

503
00:22:12,039 --> 00:22:17,889
moverlo luego mostrar los valores de los

504
00:22:14,769 --> 00:22:20,230
offsets o desviaciones obtenidas que

505
00:22:17,890 --> 00:22:22,570
podemos cargar en el numeral -define que

506
00:22:20,230 --> 00:22:25,240
vimos al principio del código y ya la

507
00:22:22,569 --> 00:22:27,879
próxima vez no deberíamos repetir el

508
00:22:25,240 --> 00:22:30,240
proceso como estaremos dando tiempo para

509
00:22:27,880 --> 00:22:33,040
ubicar el sensor indicamos colocar

510
00:22:30,240 --> 00:22:35,650
presionar cualquier tecla y enter

511
00:22:33,039 --> 00:22:38,139
entonces aquí simplemente esperamos

512
00:22:35,650 --> 00:22:40,660
hasta que se presione una tecla cuando

513
00:22:38,140 --> 00:22:44,440
eso suceda entonces invocamos unas

514
00:22:40,660 --> 00:22:48,519
funciones para calibración del mp u 60

515
00:22:44,440 --> 00:22:50,740
50 la función set address establece la

516
00:22:48,519 --> 00:22:53,529
dirección y 12 que recordarás

517
00:22:50,740 --> 00:22:58,120
establecimos con esta constante que

518
00:22:53,529 --> 00:22:59,170
equivale a 0 x 68 con el pin de 0 sin

519
00:22:58,119 --> 00:23:02,769
conexión

520
00:22:59,170 --> 00:23:05,529
luego la función calibre mp para que

521
00:23:02,769 --> 00:23:08,619
haga el proceso de obtenerlos offsets o

522
00:23:05,529 --> 00:23:11,649
desviaciones de nuestro sensor sobre la

523
00:23:08,619 --> 00:23:15,189
superficie donde se encuentra y con load

524
00:23:11,650 --> 00:23:18,070
de mp email la activación del procesador

525
00:23:15,190 --> 00:23:20,559
interno de mp para que use dichas

526
00:23:18,069 --> 00:23:24,159
desviaciones la última línea del setup

527
00:23:20,559 --> 00:23:27,730
usa la función un fijo fijo es una

528
00:23:24,160 --> 00:23:30,940
pequeña memoria que tiene el mp 60 50

529
00:23:27,730 --> 00:23:33,789
corresponde a las siglas de first input

530
00:23:30,940 --> 00:23:36,640
first output y cuando está llena con

531
00:23:33,789 --> 00:23:39,849
datos nos lo indica y llama a la función

532
00:23:36,640 --> 00:23:41,580
mostrar valores la función que ya ahora

533
00:23:39,849 --> 00:23:44,529
analizamos y es la que en definitiva

534
00:23:41,579 --> 00:23:46,839
valga la redundancia muestra los valores

535
00:23:44,529 --> 00:23:49,329
mira es que no es un código de los más

536
00:23:46,839 --> 00:23:52,389
simples pero analizando línea por línea

537
00:23:49,329 --> 00:23:54,549
podemos entender su lógica la mayoría de

538
00:23:52,390 --> 00:23:56,920
este código se reutiliza para cualquier

539
00:23:54,549 --> 00:23:59,169
proyecto que vayas a realizar con este

540
00:23:56,920 --> 00:24:02,050
sensor enviamos entonces la función

541
00:23:59,170 --> 00:24:04,450
mostrar valores no te preocupes por los

542
00:24:02,049 --> 00:24:05,509
parámetros que recibe nos centraremos en

543
00:24:04,450 --> 00:24:08,870
la función

544
00:24:05,509 --> 00:24:11,539
en esta variable es fan delay que se le

545
00:24:08,869 --> 00:24:14,389
asigna un valor de 100 corresponde a la

546
00:24:11,539 --> 00:24:17,000
demora aplicada al mostrar cada valor en

547
00:24:14,390 --> 00:24:20,480
el monitor serie es decir que muestra un

548
00:24:17,000 --> 00:24:23,359
set de valores espera 100 milisegundos y

549
00:24:20,480 --> 00:24:25,759
muestra otro set de valores declarados

550
00:24:23,359 --> 00:24:28,129
variables que usará la librería para

551
00:24:25,759 --> 00:24:31,819
obtener información del sensor y luego

552
00:24:28,130 --> 00:24:35,060
aquí un array con el nombre y pr de tres

553
00:24:31,819 --> 00:24:38,809
posiciones y por gio

554
00:24:35,059 --> 00:24:41,419
por pitch y r por rol carga en dicho

555
00:24:38,809 --> 00:24:43,220
array valores iniciales de 0 prepara

556
00:24:41,420 --> 00:24:45,380
todos para luego con una función

557
00:24:43,220 --> 00:24:48,170
específica de la librería obtener

558
00:24:45,380 --> 00:24:50,750
valores en tiempo real también se crea

559
00:24:48,170 --> 00:24:53,330
de la misma forma otro array que olvide

560
00:24:50,750 --> 00:24:55,160
mencionar antes es del tipo flauta ya

561
00:24:53,329 --> 00:24:58,369
que obtendremos valores con punto

562
00:24:55,160 --> 00:25:01,700
flotante esta vez con el nombre x y z

563
00:24:58,369 --> 00:25:04,639
como referencia de los ejes a que aplica

564
00:25:01,700 --> 00:25:07,309
la función span timer esta función de

565
00:25:04,640 --> 00:25:10,160
aquí al principio del código le asigna

566
00:25:07,309 --> 00:25:11,960
el valor de span delay que es de 100

567
00:25:10,160 --> 00:25:14,930
en definitiva aplica

568
00:25:11,960 --> 00:25:17,509
demora de 100 milisegundos utiliza una

569
00:25:14,930 --> 00:25:20,240
función para no aplicar un simple delay

570
00:25:17,509 --> 00:25:22,460
que detiene el normal flujo del programa

571
00:25:20,240 --> 00:25:25,279
verás que el resto del código está

572
00:25:22,460 --> 00:25:27,829
encerrado en esta función aquí marc con

573
00:25:25,279 --> 00:25:30,440
la apertura de llaves y cierre de las

574
00:25:27,829 --> 00:25:32,750
mismas en definitiva se ejecuta todo el

575
00:25:30,440 --> 00:25:35,299
bloque sólo se han pasado 100

576
00:25:32,750 --> 00:25:38,690
milisegundos para no saturar el monitor

577
00:25:35,299 --> 00:25:41,629
serie y estas dos funciones que ternium

578
00:25:38,690 --> 00:25:43,940
y get gravity las utiliza la librería

579
00:25:41,630 --> 00:25:47,180
para hacer los cálculos de inclinación

580
00:25:43,940 --> 00:25:50,240
de gio pitch y roll y almacena en

581
00:25:47,180 --> 00:25:54,110
variable q y gravity que luego serán

582
00:25:50,240 --> 00:25:55,940
usadas por get yo pitch roll donde ahora

583
00:25:54,109 --> 00:25:59,179
se almacena en el array

584
00:25:55,940 --> 00:26:01,910
antes creado con el nombre y pr los

585
00:25:59,180 --> 00:26:04,009
valores pero resta un paso más y es el

586
00:26:01,910 --> 00:26:07,100
de convertir los valores de grados en

587
00:26:04,009 --> 00:26:10,339
radiales a grados sexagesimal es que lo

588
00:26:07,099 --> 00:26:14,959
hace esta función convertir tu degrees y

589
00:26:10,339 --> 00:26:17,419
almacena en el segundo array x y z toda

590
00:26:14,960 --> 00:26:18,278
esta historia es para finalmente mostrar

591
00:26:17,420 --> 00:26:21,548
en el monitor

592
00:26:18,278 --> 00:26:23,618
con print flow de ex esta función a

593
00:26:21,548 --> 00:26:26,558
medida para que en una sola línea de

594
00:26:23,618 --> 00:26:30,218
código mostrar los valores primero el

595
00:26:26,558 --> 00:26:33,579
texto estático y yo el valor de la rai x

596
00:26:30,219 --> 00:26:36,940
y z en la posición 0 aquí en el

597
00:26:33,579 --> 00:26:38,978
comentario aclaró que en el índice 0 de

598
00:26:36,940 --> 00:26:41,349
la rai se encuentra el valor de la

599
00:26:38,979 --> 00:26:42,848
rotación sobre el eje z que si

600
00:26:41,348 --> 00:26:45,908
recordarás la imagen del avión

601
00:26:42,848 --> 00:26:49,118
corresponde al denominado yo siguiendo

602
00:26:45,909 --> 00:26:51,609
con la función print ex ya mostramos el

603
00:26:49,118 --> 00:26:53,829
texto el valor de la variable la

604
00:26:51,608 --> 00:26:57,009
cantidad de espacios reservados que es

605
00:26:53,829 --> 00:26:59,739
de 9 la precisión de 4 y la forma en que

606
00:26:57,009 --> 00:27:02,348
finaliza que es con una coma y cuatro

607
00:26:59,739 --> 00:27:04,929
espacios en blanco misma mecánica para

608
00:27:02,348 --> 00:27:08,858
mostrar pitch donde el valor será el de

609
00:27:04,929 --> 00:27:11,769
la rai x y z en la posición 1 y

610
00:27:08,858 --> 00:27:14,829
finalmente el rol con el array en la

611
00:27:11,769 --> 00:27:17,618
posición 2 la última línea es un clásico

612
00:27:14,829 --> 00:27:19,928
print line para dejar un salto de línea

613
00:27:17,618 --> 00:27:21,939
ahora cuando hablamos la práctica verás

614
00:27:19,929 --> 00:27:24,130
cómo queda todo bien organizado

615
00:27:21,940 --> 00:27:26,759
mostrando en cada línea los

616
00:27:24,130 --> 00:27:30,100
y actualizando a cada 100 milisegundos

617
00:27:26,759 --> 00:27:33,220
resta solamente el loop que tiene una

618
00:27:30,099 --> 00:27:37,839
sola línea con la función denominada dmp

619
00:27:33,220 --> 00:27:40,360
read fifa del objeto mp u esta función

620
00:27:37,839 --> 00:27:42,699
la debemos incorporar en el código y

621
00:27:40,359 --> 00:27:44,859
además dentro del loop para que vaya

622
00:27:42,700 --> 00:27:47,190
actualizando constantemente los valores

623
00:27:44,859 --> 00:27:49,779
y cuando hay nuevos llamen

624
00:27:47,190 --> 00:27:53,590
automáticamente a la función que recién

625
00:27:49,779 --> 00:27:56,769
vimos mostrar valores muy bien vamos a

626
00:27:53,589 --> 00:27:59,740
verificar y subir el programa la primera

627
00:27:56,769 --> 00:28:02,619
tarea es colocar el monitor serie a la

628
00:27:59,740 --> 00:28:05,829
velocidad correcta seguramente lo tengas

629
00:28:02,619 --> 00:28:08,559
a 9.600 y se muestren algunos caracteres

630
00:28:05,829 --> 00:28:12,669
sin sentido así que con este menú

631
00:28:08,559 --> 00:28:15,129
desplegable seleccionamos 115 200 esta

632
00:28:12,670 --> 00:28:17,620
acción genera un reset a automático y

633
00:28:15,130 --> 00:28:20,080
ahora si en la ventana veremos el texto

634
00:28:17,619 --> 00:28:21,729
para generar los offsets te quiero

635
00:28:20,079 --> 00:28:24,519
mostrar lo que tengo armado para la

636
00:28:21,730 --> 00:28:27,220
práctica el sensor sobre protoboard para

637
00:28:24,519 --> 00:28:29,769
tener una plataforma relativamente plana

638
00:28:27,220 --> 00:28:30,490
y también poder moverla y así ver los

639
00:28:29,769 --> 00:28:33,400
cambios

640
00:28:30,490 --> 00:28:35,950
el monitor serie anduve haciendo un poco

641
00:28:33,400 --> 00:28:38,920
de manualidades y dibuje sobre una hoja

642
00:28:35,950 --> 00:28:41,019
una vista superior de un avión de manera

643
00:28:38,920 --> 00:28:43,330
que podamos tener una referencia cuando

644
00:28:41,019 --> 00:28:46,089
giramos los ejes recordad que es

645
00:28:43,329 --> 00:28:48,428
importante la ubicación del sensor y los

646
00:28:46,089 --> 00:28:51,279
ejes se encuentran marcados sobre el

647
00:28:48,429 --> 00:28:53,920
circuito impreso genial todo listo para

648
00:28:51,279 --> 00:28:56,529
comenzar el monitor serie con el texto

649
00:28:53,920 --> 00:28:58,900
que va a generar los offsets y que

650
00:28:56,529 --> 00:29:00,670
ubiquemos el sensor y luego presionar

651
00:28:58,900 --> 00:29:02,800
cualquier tecla y enter

652
00:29:00,670 --> 00:29:05,350
yo voy a dejar ahora en esta posición

653
00:29:02,799 --> 00:29:07,899
protoboard y no moverla me aseguro de

654
00:29:05,349 --> 00:29:10,509
tener el cursor en este campo de monitor

655
00:29:07,900 --> 00:29:13,450
serie presiona cualquier tecla

656
00:29:10,509 --> 00:29:16,299
supongamos la letra g y luego enter del

657
00:29:13,450 --> 00:29:18,519
teclado o también el botón enviar de la

658
00:29:16,299 --> 00:29:21,428
ventana del monitor serie es válido

659
00:29:18,519 --> 00:29:24,129
veremos unos textos con información que

660
00:29:21,429 --> 00:29:26,740
rápidamente va pasando y en unos pocos

661
00:29:24,130 --> 00:29:29,110
segundos debemos visualizar los datos

662
00:29:26,740 --> 00:29:31,359
adquiridos del sensor verás que quedan

663
00:29:29,109 --> 00:29:32,678
bastante bien organizados en tres

664
00:29:31,359 --> 00:29:35,589
columnas para

665
00:29:32,679 --> 00:29:38,048
pitch y roll todos los valores estarán

666
00:29:35,589 --> 00:29:40,538
cercanos a 0 ya que el inicio

667
00:29:38,048 --> 00:29:42,999
justamente calibró el sensor con las

668
00:29:40,538 --> 00:29:45,339
desviaciones para la superficie donde

669
00:29:42,999 --> 00:29:47,440
tengo ahora el sensor como es muy

670
00:29:45,339 --> 00:29:50,259
sensible verás siempre algunas

671
00:29:47,440 --> 00:29:53,379
variaciones en los decimales vamos a

672
00:29:50,259 --> 00:29:56,409
aplicar una rotación sobre el eje z esto

673
00:29:53,378 --> 00:29:58,359
genera el movimiento denominado yo hará

674
00:29:56,409 --> 00:30:01,269
que la nariz de nuestro avión de papel

675
00:29:58,359 --> 00:30:03,368
se mueva de derecha a izquierda verás

676
00:30:01,269 --> 00:30:06,490
cómo van cambiando los valores de la

677
00:30:03,368 --> 00:30:08,678
primera columna la de yo idealmente no

678
00:30:06,490 --> 00:30:10,929
deberían modificarse los valores de los

679
00:30:08,679 --> 00:30:12,788
otros ejes pero como estamos todo

680
00:30:10,929 --> 00:30:14,919
conectado de forma temporal en

681
00:30:12,788 --> 00:30:17,470
protoboard que no tiene una base

682
00:30:14,919 --> 00:30:19,720
perfectamente plana existirán pequeñas

683
00:30:17,470 --> 00:30:22,929
variaciones las grandes las veremos

684
00:30:19,720 --> 00:30:25,480
sobre el eje yo en este caso voy a

685
00:30:22,929 --> 00:30:27,840
moverlo en el otro sentido y verás cómo

686
00:30:25,480 --> 00:30:30,669
cambian estos valores son grados

687
00:30:27,839 --> 00:30:33,908
sexagesimal es así que ahora estamos a

688
00:30:30,669 --> 00:30:36,460
unos 29 grados desde el inicio podemos

689
00:30:33,909 --> 00:30:39,159
volver a intentar colocarlo a cero

690
00:30:36,460 --> 00:30:40,120
recuerda que esta posición es relativa

691
00:30:39,159 --> 00:30:43,060
para cuando inicia

692
00:30:40,119 --> 00:30:46,149
es decir que yo no tiene una posición

693
00:30:43,059 --> 00:30:48,609
absoluta la definimos nosotros muy bien

694
00:30:46,150 --> 00:30:51,700
aquí estamos bastante cerca de cero

695
00:30:48,609 --> 00:30:54,099
vemos la rotación sobre el eje y que

696
00:30:51,700 --> 00:30:56,650
genera el pitch podrás ver los cambios

697
00:30:54,099 --> 00:30:59,230
en la segunda columna ahí comienzo a

698
00:30:56,650 --> 00:31:02,500
moverlo nuestro avión comienza a elevar

699
00:30:59,230 --> 00:31:04,240
su nariz unos 25 grados si ahora dejo

700
00:31:02,500 --> 00:31:06,549
protoboard nuevamente sobre la

701
00:31:04,240 --> 00:31:07,779
superficie del escritorio verás que

702
00:31:06,549 --> 00:31:10,419
vuelve a cero

703
00:31:07,779 --> 00:31:13,269
si ahora giro el eje y haciendo que la

704
00:31:10,420 --> 00:31:15,730
nariz baje tendremos un pitch de un

705
00:31:13,269 --> 00:31:18,549
determinado ángulo pero esta vez con un

706
00:31:15,730 --> 00:31:21,490
signo menos en definitiva el signo nos

707
00:31:18,549 --> 00:31:23,529
indica que el sentido de giro es opuesto

708
00:31:21,490 --> 00:31:25,870
al anterior esto es importante para

709
00:31:23,529 --> 00:31:28,720
saber si nuestro avión está subiendo o

710
00:31:25,869 --> 00:31:32,289
bajando un pitch positivo es nariz

711
00:31:28,720 --> 00:31:35,049
arriba 1 negativo abajo por último queda

712
00:31:32,289 --> 00:31:38,319
verificar el rol verás que cuando aplicó

713
00:31:35,049 --> 00:31:40,839
un giro sobre el eje x una la baja y la

714
00:31:38,319 --> 00:31:43,509
otra sube y vemos en la última columna

715
00:31:40,839 --> 00:31:45,789
el ángulo exacto nuevamente podemos

716
00:31:43,509 --> 00:31:46,750
volver a cero y haciendo un giro en

717
00:31:45,789 --> 00:31:49,089
sentido

718
00:31:46,750 --> 00:31:51,880
tendremos un ángulo pero con signo

719
00:31:49,089 --> 00:31:54,279
negativo todo funciona correctamente y

720
00:31:51,880 --> 00:31:56,770
se condice con todos los conceptos que

721
00:31:54,279 --> 00:31:59,139
vimos previamente vamos a ver los

722
00:31:56,769 --> 00:32:01,660
famosos offsets que generó de forma

723
00:31:59,140 --> 00:32:04,450
automática para eso voy a cerrar el

724
00:32:01,660 --> 00:32:06,730
monitor serie y volverlo a abrir muestra

725
00:32:04,450 --> 00:32:09,160
nuevamente el texto ya conocido

726
00:32:06,730 --> 00:32:12,279
aguardamos unos segundos y boyantes

727
00:32:09,160 --> 00:32:14,920
chequear la casilla auto scroll el

728
00:32:12,279 --> 00:32:16,960
monitor serie sigue mostrando datos pero

729
00:32:14,920 --> 00:32:19,060
ya nos deja liberada la barra de

730
00:32:16,960 --> 00:32:21,880
desplazamiento vertical porque quiero

731
00:32:19,059 --> 00:32:24,039
ver desde el inicio que pasó muy rápido

732
00:32:21,880 --> 00:32:26,650
vemos textos son varios que no tienen

733
00:32:24,039 --> 00:32:28,990
relevancia por ahora y luego una línea

734
00:32:26,650 --> 00:32:31,660
que comienza con un numeral -define y

735
00:32:28,990 --> 00:32:33,970
lleva el nombre de offsets estos son los

736
00:32:31,660 --> 00:32:36,220
valores calculados de forma automática

737
00:32:33,970 --> 00:32:38,799
por la librería del sensor para que esté

738
00:32:36,220 --> 00:32:40,809
todo en cero al iniciar el volcado de

739
00:32:38,799 --> 00:32:43,299
datos esta línea completa la

740
00:32:40,809 --> 00:32:46,299
seleccionamos y copiamos con el atajo de

741
00:32:43,299 --> 00:32:48,579
teclado control y la letra si ya que la

742
00:32:46,299 --> 00:32:50,950
colocaremos en el programa antes de

743
00:32:48,579 --> 00:32:53,439
salir mejor volvemos a chequear el auto

744
00:32:50,950 --> 00:32:55,808
scroll y todo vuelve a la normalidad

745
00:32:53,440 --> 00:32:58,778
hagamos una modificación al código e

746
00:32:55,808 --> 00:33:01,000
incorporemos los objetos o desviaciones

747
00:32:58,778 --> 00:33:04,089
que generó el programa para el sensor

748
00:33:01,000 --> 00:33:06,009
ubicado en mi superficie un escritorio

749
00:33:04,089 --> 00:33:08,528
claro que en tu caso cuando hagas la

750
00:33:06,009 --> 00:33:11,288
práctica estos valores serán distintos

751
00:33:08,528 --> 00:33:13,659
entonces aquí podemos seleccionar esta

752
00:33:11,288 --> 00:33:16,778
línea comentada al principio y con

753
00:33:13,659 --> 00:33:19,509
control y la letra be corta pegar ahora

754
00:33:16,778 --> 00:33:21,788
como ya tenemos offsets iniciales el

755
00:33:19,509 --> 00:33:24,159
programa ya no nos pedirá nada como

756
00:33:21,788 --> 00:33:26,019
antes dicho que podemos verificar en

757
00:33:24,159 --> 00:33:28,840
esta directiva al compilador que

758
00:33:26,019 --> 00:33:31,388
consulta por dicho numeral defile hasta

759
00:33:28,839 --> 00:33:34,658
ahora no teníamos por eso íbamos a la

760
00:33:31,388 --> 00:33:37,209
condición falsa al else ya la situación

761
00:33:34,659 --> 00:33:39,820
es distinta esta directiva ahora es

762
00:33:37,210 --> 00:33:43,179
verdadera entonces sólo mostrará en el

763
00:33:39,819 --> 00:33:45,849
monitor serie usando offset predefinidos

764
00:33:43,179 --> 00:33:49,059
y llama a la función de inicialización

765
00:33:45,849 --> 00:33:53,859
en este caso ya no ejecuta calibre

766
00:33:49,058 --> 00:33:55,119
mp y el load dmp email que antes estaba

767
00:33:53,859 --> 00:33:57,128
sin parámetro

768
00:33:55,119 --> 00:33:58,178
ahora carga los del numeral design

769
00:33:57,128 --> 00:34:00,788
offset

770
00:33:58,179 --> 00:34:03,460
vamos a verificar y subir esta pequeña

771
00:34:00,788 --> 00:34:06,128
modificación y como no podía ser de otra

772
00:34:03,460 --> 00:34:08,440
manera al abrir el monitor serie ya no

773
00:34:06,128 --> 00:34:11,168
nos pide que presionemos una tecla y

774
00:34:08,440 --> 00:34:13,409
enter para generar offsets simplemente

775
00:34:11,168 --> 00:34:15,818
nos indica que está usando los offset

776
00:34:13,409 --> 00:34:18,669
predefinidos y comienza a hacer el

777
00:34:15,818 --> 00:34:20,769
volcado de forma automática para este

778
00:34:18,668 --> 00:34:22,960
último programa del capítulo voy a

779
00:34:20,769 --> 00:34:25,210
volver a comentar la línea del numeral

780
00:34:22,960 --> 00:34:27,280
design offset porque quiero que los

781
00:34:25,210 --> 00:34:29,588
vuelva a generar y quiero también

782
00:34:27,280 --> 00:34:31,869
mostrarte lo simple que es tomar una

783
00:34:29,588 --> 00:34:34,599
acción cuando se llegan a determinados

784
00:34:31,869 --> 00:34:36,940
valores para hacerlo simple supongamos

785
00:34:34,599 --> 00:34:39,550
que estamos monitoreando el pitch de

786
00:34:36,940 --> 00:34:42,398
nuestro avión o vehículos que circula en

787
00:34:39,550 --> 00:34:44,879
tierra tipo rover por ejemplo el pitch

788
00:34:42,398 --> 00:34:47,469
se produce con la rotación del eje y

789
00:34:44,878 --> 00:34:50,049
deseamos que nos notifique en el monitor

790
00:34:47,469 --> 00:34:52,568
serie si el pitch y la nariz de nuestro

791
00:34:50,050 --> 00:34:55,359
avión de proto papel superan los 10

792
00:34:52,568 --> 00:34:58,000
grados ya sea hacia arriba o hacia abajo

793
00:34:55,358 --> 00:35:00,369
muy fácil es implementarlo

794
00:34:58,000 --> 00:35:02,619
vamos a usar unos condicionales dentro

795
00:35:00,369 --> 00:35:04,000
de la función que es llamada cada vez

796
00:35:02,619 --> 00:35:07,059
que tenemos datos

797
00:35:04,000 --> 00:35:09,030
mostrar valores luego del ping line pego

798
00:35:07,059 --> 00:35:11,860
el bloque y ahora lo analizamos

799
00:35:09,030 --> 00:35:15,760
simplemente hacemos una consulta por el

800
00:35:11,860 --> 00:35:18,640
valor de la rai x y z en el índice 1

801
00:35:15,760 --> 00:35:20,890
recuerda que el índice 1 de dicho array

802
00:35:18,639 --> 00:35:23,980
tiene el valor de rotación sobre el eje

803
00:35:20,889 --> 00:35:26,679
y que es el pitch consultamos si dicho

804
00:35:23,980 --> 00:35:28,990
valor es mayor a 10 así de fácil

805
00:35:26,679 --> 00:35:32,169
si es el caso mostramos en el monitor

806
00:35:28,989 --> 00:35:32,919
serie el texto nariz arriba si no es el

807
00:35:32,170 --> 00:35:37,090
caso

808
00:35:32,920 --> 00:35:39,909
consultamos si x y z en el índice 1 es

809
00:35:37,090 --> 00:35:42,490
menor a menos 10 por cierto verás que

810
00:35:39,909 --> 00:35:45,819
colocó 10.0 ya que estamos trabajando

811
00:35:42,489 --> 00:35:48,279
con valores de punto flotante entonces

812
00:35:45,820 --> 00:35:50,980
sí es cierto que el pitch es menor a

813
00:35:48,280 --> 00:35:53,980
menos 10 grados escribimos en el monitor

814
00:35:50,980 --> 00:35:57,099
serie nariz abajo claro que esto es muy

815
00:35:53,980 --> 00:35:58,630
simple pero creo ilustra el potencial de

816
00:35:57,099 --> 00:36:02,079
que con un simple condicional

817
00:35:58,630 --> 00:36:04,840
preguntamos si un ángulo es mayor menor

818
00:36:02,079 --> 00:36:07,239
o está dentro de determinado rango y

819
00:36:04,840 --> 00:36:10,450
aplicamos una acción en vez de mostrar

820
00:36:07,239 --> 00:36:13,899
un texto podrías con un digital write

821
00:36:10,449 --> 00:36:16,679
un pin digital que enciende un active un

822
00:36:13,900 --> 00:36:19,450
servomotor un relé o lo que quieras

823
00:36:16,679 --> 00:36:22,210
verifiquemos y subamos este programa

824
00:36:19,449 --> 00:36:24,309
abrimos el monitor serie nos indica que

825
00:36:22,210 --> 00:36:26,380
va a generar los objetos lo cual es

826
00:36:24,309 --> 00:36:28,570
correcto ya que tenemos al numeral

827
00:36:26,380 --> 00:36:30,820
design comentado pero vimos como

828
00:36:28,570 --> 00:36:34,210
colocando los nuestros podemos saltar

829
00:36:30,820 --> 00:36:36,550
este paso presionar una tecla y enter y

830
00:36:34,210 --> 00:36:38,679
luego de unos segundos ya comenzamos a

831
00:36:36,550 --> 00:36:40,780
ver los datos entonces la idea es

832
00:36:38,679 --> 00:36:43,690
comenzar a elevar la nariz para que el

833
00:36:40,780 --> 00:36:46,060
pitch sea mayor a 10 grados cuando eso

834
00:36:43,690 --> 00:36:48,880
suceda deberá intercalarse con los datos

835
00:36:46,059 --> 00:36:52,659
el texto de nariz a arriba voy subiendo

836
00:36:48,880 --> 00:36:55,180
voy subiendo y bien ya muestra el texto

837
00:36:52,659 --> 00:36:58,088
ha detectado correctamente la condición

838
00:36:55,179 --> 00:37:01,149
y toma la acción ahora vuelvo a un pitch

839
00:36:58,088 --> 00:37:04,599
menor verás que ya con valores menores a

840
00:37:01,150 --> 00:37:06,940
10 no intercala texto ahora nariz abajo

841
00:37:04,599 --> 00:37:08,859
de a poco a ver qué sucede y

842
00:37:06,940 --> 00:37:11,920
efectivamente al llegar a valores

843
00:37:08,858 --> 00:37:14,650
menores al menos 10 nos muestra el texto

844
00:37:11,920 --> 00:37:15,880
nariz abajo funciona tal cual lo

845
00:37:14,650 --> 00:37:17,139
programado

846
00:37:15,880 --> 00:37:20,318
entonces decimos 1

847
00:37:17,139 --> 00:37:22,028
muy completo de fácil conexión y que nos

848
00:37:20,318 --> 00:37:24,608
brinda gran cantidad de información

849
00:37:22,028 --> 00:37:26,889
ideal para vehículos autónomos no

850
00:37:24,608 --> 00:37:29,528
tripulados también para aquellos tipos

851
00:37:26,889 --> 00:37:32,199
robert plataformas de estabilización o

852
00:37:29,528 --> 00:37:34,150
guim valls y muchos otros usos

853
00:37:32,199 --> 00:37:35,858
de hecho en capítulos futuros estaremos

854
00:37:34,150 --> 00:37:38,588
viendo algunas implementaciones

855
00:37:35,858 --> 00:37:42,038
prácticas basadas en todos los conceptos

856
00:37:38,588 --> 00:37:43,298
adquiridos en este presente capítulo eso

857
00:37:42,039 --> 00:37:45,819
es todo por este capítulo

858
00:37:43,298 --> 00:37:48,548
si te pareció interesante recuerda dejar

859
00:37:45,818 --> 00:37:51,548
un me gusta suscribirte y activar la

860
00:37:48,548 --> 00:37:54,159
campana para recibir una notificación ni

861
00:37:51,548 --> 00:37:55,710
bien se publica el nuevo material y como

862
00:37:54,159 --> 00:38:00,009
siempre por cualquier duda o comentario

863
00:37:55,710 --> 00:38:02,220
lo podrás hacer debajo chao y hasta la

864
00:38:00,010 --> 00:38:02,220
próxima

